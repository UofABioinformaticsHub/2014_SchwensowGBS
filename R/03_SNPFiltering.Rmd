---
title: "SNP Filtering"
author: "Steve Pederson"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    fig_caption: yes
    fig_height: 6
    fig_width: 10
    toc: true
    toc_float: true
    code_folding: hide    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE, 
  message = FALSE
)
```

## Setup

```{r loadPackages}
library(SeqArray)
library(SNPRelate)
library(pander)
library(scales)
library(magrittr)
library(tidyverse)
theme_set(theme_bw())
```

This workflow goes through multiple steps involved in processing the stacks output:

1. Beginning with the VCF, this will be converted to a GDS object for easier interaction.
As this is a slow conversion process, this will only be performed once.
The resulting object will be used to prune SNPs in Linkage Disequilibrium.
Notably, this VCF is not available in this github repo as it is ~92Mb and too large.
Likewise the prepared GDS object is 86.6Mb, which is also too large for storage on github.


### VCF Conversion to GDS

```{r vcf2gds}
gdsPath <- file.path("..", "5_stacks", "gds", "populations.snps.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
    dir.create(dirname(gdsPath))
    file.path("..", "5_stacks", "vcf", "populations.snps.vcf.gz") %>%
        seqVCF2GDS(gdsPath, reference = "OryCun2.0")
}
gdsFile <- seqOpen(gdsPath, readonly = FALSE)
```

Sample information and subsequent population information was then extracted and added to the GDS file.

```{r sampleID}
sampleID <- seqGetData(gdsFile, "sample.id") %>%
    as.data.frame(stringsAsFactors = FALSE) %>%
    set_names("Sample") %>%
    mutate(Population = case_when(
        grepl("gc", Sample) ~ 1996L,
        grepl("ora", Sample) ~ 2012L,
        !grepl("(gc|ora)", Sample) ~ 2010L
    ),
    Location = case_when(
        Population == 1996 ~ "Gum Creek",
        Population == 2012 ~ "Oraparinna",
        Population == 2010 ~ "Turretfield"
    )) %>%
    as_tibble()
```

```{r addAnnotation}
if (makeGds) {
  add.gdsn(gdsFile, "sample.annotation", sampleID, replace = TRUE)
  seqClose(gdsFile)
  gdsFile <- seqOpen(gdsPath, readonly = FALSE)
}
```

### SNP Data Summary

```{r chromosomes}
chromosomes <- paste0("chr", c(1:21, "X"))
scaffolds <- seqGetData(gdsFile, "chromosome") %>%
    unique() %>%
    setdiff(chromosomes)
```


Let's just check the distances, depth and SNP numbers on the main chromosomes

```{r snpSummary}
snpSummary <- tibble(
    variant.id = seqGetData(gdsFile, "variant.id") ,
    chromosome = seqGetData(gdsFile, "chromosome"),
    position = seqGetData(gdsFile, "position")
) %>%
    cbind(
      seqGetData(gdsFile, "annotation/format/DP")$data %>% 
        t %>%
        set_colnames(sampleID$Sample)
    ) %>%
    as_tibble()
```

Checking the call rate across all samples, 5x1996 samples with SNP call rates < 50% were identified. 
This value was not exceeded by any samples in the 2010 or 2012 populations.

```{r plotCallRate, fig.cap="*Summary of SNP call rate in all samples*", fig.height=12}
snpSummary %>%
    mutate_at(sampleID$Sample, list(is.na)) %>%
    summarise_at(sampleID$Sample, list(sum)) %>%
    gather(key = "Sample", value = "Missing") %>%
    mutate(Called = nrow(snpSummary) - Missing) %>%
    gather(key = "Type", value = "SNPs", -Sample) %>%
    left_join(sampleID) %>%
    ggplot(aes(Sample, SNPs / nrow(snpSummary), fill = Type)) +
    geom_bar(stat = "identity") +
    geom_hline(yintercept = 0.5, linetype = 2) +
    facet_wrap(~Population, scales = "free") +
    coord_flip() +
    labs(y = "Percent Called") +
    scale_y_continuous(expand = expand_scale(0, 0), labels = percent) +
    scale_fill_manual(values = c("green", "red"))
```

```{r plotDepth, fig.cap="*Summary of sequencing depth across all SNPs for each sample*", fig.height=14}
minDepth <- 5
maxDepth <- 100
snpSummary %>%
  gather(key = "Sample", value = "Depth", -variant.id, -chromosome, -position) %>%
  dplyr::filter(!is.na(Depth)) %>%
  left_join(sampleID) %>%
  ggplot(aes(x = Sample, y = Depth)) +
  geom_boxplot() +
  geom_hline(yintercept = c(minDepth, maxDepth), linetype = 2, colour = "blue") +
  scale_y_log10() +
  coord_flip() +
  facet_grid(Population ~ ., scales = "free_y", space = "free_y")
```

```{r maxDepth}
snpOKDepth <- snpSummary %>%
  gather(key = "Sample", value = "Depth", -variant.id, -chromosome, -position) %>%
  dplyr::filter(!is.na(Depth)) %>% 
  group_by(variant.id) %>% 
  summarise(Depth = median(Depth)) %>% 
  dplyr::filter(Depth < maxDepth & Depth > minDepth) %>%
  .[["variant.id"]]
```


SNPs with a median sequencing depth > `r maxDepth` were marked for removal as these were considered likely to indicate duplications as opposed to unique SNPs.
Similarly, SNPs with a median sequencing depth < `r minDepth` were marked for removal as being of low confidence,
This removed a total of `r comma(nrow(snpSummary) - length(snpOKDepth))` SNPs, leaving `r comma(length(snpOKDepth))` SNPs available for linkage pruning.

No SNPs were found being unique to Turretfield, which is as expected by the settings given to `stacks`

```{r tfSNPs, eval=FALSE}
tfSNPs <- snpSummary %>%
    gather(key = "Sample", value = "DP", -variant.id, -chromosome, -position) %>%
    mutate(DP = !is.na(DP)) %>%
    left_join(sampleID) %>%
    group_by(variant.id, chromosome, position, Population) %>%
    summarise(n = sum(DP)) %>%
    spread(key = "Population", value = n) %>%
    filter(`1996` == 0 & `2012` == 0)
```


### LD Pruning

```{r ldPruning, results='hide'}
set.seed(1523)
minMaf <- 0.05
missingRate <- 0.25
minCor <- 0.4
snpset <- gdsFile %>%
    snpgdsLDpruning(
        sample.id = grep("(gc|ora)", seqGetData(., "sample.id"), value = TRUE),
        snp.id = snpOKDepth,
        autosome.only = FALSE,
        maf = minMaf,
        missing.rate = missingRate,
        method = "corr",
        ld.threshold = minCor
        ) %>%
    .[setdiff(names(.), "chrX")]
```

SNPs were pruned for Linkage Disequilibrium using only samples from the 1996 and 2012 populations and the following criteria:

- Minor Allele Frequency > `r percent(minMaf)`
- Missing Data in < `r percent(missingRate)` of samples
- Correlation of > `r percent(minCor)` indicating LD

This has given `r comma(sum(vapply(snpset, length, integer(1))))` SNPs as candidates for downstream analysis

```{r resetFilter, results='hide'}
seqResetFilter(gdsFile) 
```

```{r, keepSNPs}
keepSNPs <- c("variant.id", "position", "chromosome") %>%
    sapply(function(x){
        seqGetData(gdsFile, x)
    }, simplify = FALSE) %>%
    as_tibble() %>%
    dplyr::filter(variant.id %in% unlist(snpset))
```

```{r plotKeepSNPs, echo = FALSE, fig.cap = "*Summary of SNPs per chromosome after filtering for LD.*"}
keepSNPs %>%
    dplyr::filter(chromosome %in% c(1:22, "X")) %>%
    group_by(chromosome) %>%
    tally() %>%
    mutate(chromosome = factor(chromosome, levels = 1:21)) %>%
    droplevels() %>%
    arrange(chromosome) %>%
    ggplot(aes(chromosome, n)) +
    geom_bar(stat = "identity") +
    labs(x = "Primary Chromosomes",
         y = "Number of SNPs retained for initial analysis") +
    scale_x_discrete()
```


This set of SNPs was then exported as an R object for downstream use.

```{r}
write_rds(keepSNPs, "keepSNPsAfterLDPruning.RDS")
```

## SessionInfo

```{r}
pander(sessionInfo())
```

